local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Camera = workspace.CurrentCamera

local menu = Instance.new("ScreenGui", PlayerGui)
menu.Name = "IdkGui"
menu.ResetOnSpawn = false

local menuframe = Instance.new("Frame", menu)
menuframe.BackgroundColor3 = Color3.fromRGB(23, 124, 255)
menuframe.Position = UDim2.new(0.162, 0, 0.314, 0)
menuframe.Size = UDim2.new(0, 233, 0, 502)

local MoveGuiButton = Instance.new("TextButton", menuframe)
MoveGuiButton.Position = UDim2.new(0, 0, 0, 0)
MoveGuiButton.Size = UDim2.new(1, -24, 0, 20)
MoveGuiButton.Text = "IdkGui"
MoveGuiButton.AutoButtonColor = false
MoveGuiButton.BorderSizePixel = 0
MoveGuiButton.TextColor3 = Color3.new(1,1,1)
local CloseGuiButton = Instance.new("TextButton", menuframe)
CloseGuiButton.Position = UDim2.new(1, -24, 0, 0)
CloseGuiButton.Size = UDim2.new(0, 24, 0, 20)
CloseGuiButton.Text = "X"
CloseGuiButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
CloseGuiButton.TextColor3 = Color3.new(1,1,1)
CloseGuiButton.BorderSizePixel = 0

CloseGuiButton.MouseButton1Click:Connect(function()
	menu:Destroy()
end)

local mouse = game:GetService("Players").LocalPlayer:GetMouse()
MoveGuiButton.MouseButton1Down:Connect(function()
	menuframe.Position = UDim2.new(0, mouse.X-100, 0, mouse.Y-5)
end)

local GhostModeButton = Instance.new("TextButton", menuframe)
GhostModeButton.Position = UDim2.new(0.069, 0, 0.105, 0)
GhostModeButton.Size = UDim2.new(0, 200, 0, 50)
GhostModeButton.Text = "Ghost Mode"

local ghostModeActive = false
local platformInstance = nil
local originalCollisions = {}

GhostModeButton.MouseButton1Click:Connect(function()
	if ghostModeActive then return end

	local character = LocalPlayer.Character
	if not character then return end

	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end

	ghostModeActive = true
	GhostModeButton.Text = "Ghost Mode (Active)"
	GhostModeButton.BackgroundColor3 = Color3.fromRGB(150, 150, 150)

	originalCollisions = {}

	for _, descendant in Workspace:GetDescendants() do
		if descendant:IsA("BasePart") and not descendant:IsDescendantOf(character) then
			originalCollisions[descendant] = descendant.CanCollide
			descendant.CanCollide = false
		end
	end

	for _, descendant in character:GetDescendants() do
		if descendant:IsA("BasePart") then
			descendant.Transparency = 0.5
		end
	end
	for _, descendant in character:GetDescendants() do
		if descendant.Name == "HumanoidRootPart" then
			descendant.Transparency = 1
		end
	end
	if humanoidRootPart then
		humanoidRootPart.Transparency = 1
	end

	if platformInstance then platformInstance:Destroy() end

	platformInstance = Instance.new("Part")
	platformInstance.Name = "SpawnPlatform"
	platformInstance.Size = Vector3.new(350, 1, 350)
	platformInstance.Transparency = 1
	platformInstance.Material = Enum.Material.Plastic
	platformInstance.Anchored = true
	platformInstance.CanCollide = true

	local rootPosition = humanoidRootPart.Position
	local rootSize = humanoidRootPart.Size
	local platformSize = platformInstance.Size
	local platformYOffset = rootSize.Y / 2 + platformSize.Y / 2 + 2
	local platformPosition = rootPosition - Vector3.new(0, platformYOffset, 0)

	platformInstance.Position = platformPosition
	platformInstance.Parent = Workspace

	task.delay(6, function()
		for part, canCollide in originalCollisions do
			if part and part.Parent then
				part.CanCollide = canCollide
			end
		end
		originalCollisions = {}

		if platformInstance then
			platformInstance:Destroy()
			platformInstance = nil
		end

		local currentChar = LocalPlayer.Character
		if currentChar then
			local currentHRP = currentChar:FindFirstChild("HumanoidRootPart")
			for _, descendant in currentChar:GetDescendants() do
				if descendant:IsA("BasePart") then
					descendant.Transparency = 0
				end
			end
		end
		for _, descendant in character:GetDescendants() do
			if descendant.Name == "HumanoidRootPart" then
				descendant.Transparency = 1
			end
		end
		ghostModeActive = false
		GhostModeButton.Text = "Ghost Mode"
		GhostModeButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	end)
end)

local UltraInstinctButton = Instance.new("TextButton", menuframe)
UltraInstinctButton.Name = "UltraInstinctButton"
UltraInstinctButton.Position = UDim2.new(0.069, 0, 0.251, 0)
UltraInstinctButton.Size = UDim2.new(0, 200, 0, 50)
UltraInstinctButton.Text = "Ultra Instinct"

local ultraInstinctEnabled = false
local playerHealthMap = {}
local TWEEN_DISTANCE = 18
local TWEEN_DURATION = 0.25
local activeTweens = {}

local function onCharacterAdded(character)
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		playerHealthMap[humanoid] = humanoid.Health

		humanoid.HealthChanged:Connect(function(newHealth)
			if not ultraInstinctEnabled or character ~= LocalPlayer.Character then
				playerHealthMap[humanoid] = newHealth
				return
			end

			local previousHealth = playerHealthMap[humanoid]

			if previousHealth and newHealth < previousHealth then
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if rootPart then
					if activeTweens[rootPart] then
						activeTweens[rootPart]:Cancel()
						activeTweens[rootPart] = nil
					end

					local dodgeDirection = (math.random(0, 1) == 0 and -1 or 1) * rootPart.CFrame.RightVector
					local targetCFrame = rootPart.CFrame + dodgeDirection * TWEEN_DISTANCE
					local tweenInfo = TweenInfo.new(TWEEN_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
					local tween = TweenService:Create(rootPart, tweenInfo, { CFrame = targetCFrame })

					activeTweens[rootPart] = tween

					tween.Completed:Connect(function()
						activeTweens[rootPart] = nil
					end)

					tween:Play()
				end
			end
			playerHealthMap[humanoid] = humanoid.Health
		end)

		humanoid.Died:Connect(function()
			playerHealthMap[humanoid] = nil
			local rootPart = character:FindFirstChild("HumanoidRootPart")
			if rootPart and activeTweens[rootPart] then
				activeTweens[rootPart]:Cancel()
				activeTweens[rootPart] = nil
			end
		end)
	end
end

local function onPlayerAdded(player)
	player.CharacterAdded:Connect(onCharacterAdded)
	if player.Character then
		onCharacterAdded(player.Character)
	end
end

Players.PlayerAdded:Connect(onPlayerAdded)

for _, player in Players:GetPlayers() do
	task.spawn(onPlayerAdded, player)
end

UltraInstinctButton.MouseButton1Click:Connect(function()
	ultraInstinctEnabled = not ultraInstinctEnabled

	if ultraInstinctEnabled then
		UltraInstinctButton.Text = "Ultra Instinct: ON"
		UltraInstinctButton.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
	else
		UltraInstinctButton.Text = "Ultra Instinct"
		UltraInstinctButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	end
end)

if ultraInstinctEnabled then
	UltraInstinctButton.Text = "Ultra Instinct: ON"
	UltraInstinctButton.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
else
	UltraInstinctButton.Text = "Ultra Instinct"
	UltraInstinctButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
end

local Jump_SpeedButton = Instance.new("TextButton", menuframe)
Jump_SpeedButton.Position = UDim2.new(0.069, 0, 0.397, 0)
Jump_SpeedButton.Size = UDim2.new(0, 200, 0, 50)
Jump_SpeedButton.Text = "Jump+Speed"
Jump_SpeedButton.MouseButton1Click:Connect(function()
	local char = game.Players.LocalPlayer.Character
	if char then
		local hum = char:FindFirstChildOfClass("Humanoid")
		if hum then
			hum.WalkSpeed = 200
			hum.UseJumpPower = true
			hum.JumpPower = 150
		end
	end
end)

local FlyButton = Instance.new("TextButton", menuframe)
FlyButton.Position = UDim2.new(0.069, 0, 0.543, 0)
FlyButton.Size = UDim2.new(0, 200, 0, 50)
FlyButton.Text = "Fly"

local isFlying = false
local flySpeed = 50
local flyGyro = nil
local flyVelocity = nil

local moveInputs = {
	Forward = Enum.KeyCode.W,
	Backward = Enum.KeyCode.S,
	Left = Enum.KeyCode.A,
	Right = Enum.KeyCode.D,
	Up = Enum.KeyCode.Space,
	Down = Enum.KeyCode.LeftShift
}
local currentMoveInputs = {}

local function cleanupFlyMovers()
	if flyGyro then
		flyGyro:Destroy()
		flyGyro = nil
	end
	if flyVelocity then
		flyVelocity:Destroy()
		flyVelocity = nil
	end
end

local function toggleFly()
	local character = LocalPlayer.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then return end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	local rootPart = character.HumanoidRootPart

	isFlying = not isFlying

	if isFlying then
		cleanupFlyMovers()

		flyGyro = Instance.new("BodyGyro")
		flyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
		flyGyro.P = 10000
		flyGyro.D = 500
		flyGyro.Parent = rootPart

		flyVelocity = Instance.new("BodyVelocity")
		flyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
		flyVelocity.P = 5000
		flyVelocity.Velocity = Vector3.new(0, 0, 0)
		flyVelocity.Parent = rootPart

		humanoid.PlatformStand = true

		FlyButton.Text = "Fly [ON]"
		FlyButton.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
	else
		cleanupFlyMovers()
		humanoid.PlatformStand = false

		FlyButton.Text = "Fly [OFF]"
		FlyButton.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
	end
end

RunService.Heartbeat:Connect(function(dt)
	if isFlying and flyGyro and flyVelocity then
		local character = LocalPlayer.Character
		if not character or not character:FindFirstChild("HumanoidRootPart") then
			cleanupFlyMovers()
			isFlying = false
			FlyButton.Text = "Fly [OFF]"
			FlyButton.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
			local hum = character and character:FindFirstChildOfClass("Humanoid")
			if hum then hum.PlatformStand = false end
			return
		end

		local rootPart = character.HumanoidRootPart
		local currentRotation = Camera.CFrame

		flyGyro.CFrame = currentRotation

		local moveDirection = Vector3.new(0, 0, 0)
		if currentMoveInputs[moveInputs.Forward] then
			moveDirection = moveDirection + currentRotation.LookVector
		end
		if currentMoveInputs[moveInputs.Backward] then
			moveDirection = moveDirection - currentRotation.LookVector
		end
		if currentMoveInputs[moveInputs.Left] then
			moveDirection = moveDirection - currentRotation.RightVector
		end
		if currentMoveInputs[moveInputs.Right] then
			moveDirection = moveDirection + currentRotation.RightVector
		end
		if currentMoveInputs[moveInputs.Up] then
			moveDirection = moveDirection + Vector3.new(0, 1, 0)
		end
		if currentMoveInputs[moveInputs.Down] then
			moveDirection = moveDirection - Vector3.new(0, 1, 0)
		end

		if moveDirection.Magnitude > 0 then
			flyVelocity.Velocity = moveDirection.Unit * flySpeed
		else
			flyVelocity.Velocity = Vector3.new(0, 0, 0)
		end
	elseif not isFlying then
		if flyVelocity then flyVelocity.Velocity = Vector3.new(0,0,0) end
	end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
	if gameProcessedEvent then return end

	for _, keycode in moveInputs do
		if input.KeyCode == keycode then
			currentMoveInputs[keycode] = true
			break
		end
	end
end)

UserInputService.InputEnded:Connect(function(input)
	for _, keycode in moveInputs do
		if input.KeyCode == keycode then
			currentMoveInputs[keycode] = false
			break
		end
	end
end)

FlyButton.MouseButton1Click:Connect(toggleFly)

FlyButton.Text = "Fly [OFF]"
FlyButton.BackgroundColor3 = Color3.fromRGB(170, 0, 0)

local CrashButton = Instance.new("TextButton", menuframe)
CrashButton.Position = UDim2.new(0.069, 0, 0.683, 0)
CrashButton.Size = UDim2.new(0, 200, 0, 50)
CrashButton.Text = "Crash Server (Fixed, dont working)"

CrashButton.MouseButton1Click:Connect(function()

	while wait(0.6) do
		game:GetService("NetworkClient"):SetOutgoingKBPSLimit(math.huge)
		local function getmaxvalue(val)
			local mainvalueifonetable = 499999
			if type(val) ~= "number" then
				return nil
			end
			local calculateperfectval = (mainvalueifonetable/(val+2))
			return calculateperfectval
		end

		local function bomb(tableincrease, tries)
			local maintable = {}
			local spammedtable = {}

			table.insert(spammedtable, {})
			z = spammedtable[1]

			for i = 1, tableincrease do
				local tableins = {}
				table.insert(z, tableins)
				z = tableins
			end

			local calculatemax = getmaxvalue(tableincrease)
			local maximum

			if calculatemax then
				maximum = calculatemax
			else
				maximum = 999999
			end

			for i = 1, maximum do
				table.insert(maintable, spammedtable)
			end

			for i = 1, tries do
				game.RobloxReplicatedStorage.SetPlayerBlockList:FireServer(maintable)
			end
		end

		bomb(250, 2)
	end
end)

local AdminCommands = Instance.new("TextButton", menuframe)
AdminCommands.Position = UDim2.new(0.069, 0, 0.823, 0)
AdminCommands.Size = UDim2.new(0, 200, 0, 50)
AdminCommands.Text = "Admin Commands"

AdminCommands.MouseButton1Click:Connect(function()
	local success, err = pcall(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
	end)
	if not success then
		warn("Failed to load Infinite Yield:", err)
	end
end)

LocalPlayer.CharacterAdded:Connect(function(character)
	if isFlying then
		isFlying = false
		cleanupFlyMovers()
		FlyButton.Text = "Fly [OFF]"
		FlyButton.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
	end
	currentMoveInputs = {}

	onCharacterAdded(character)

	local humanoid = character:WaitForChild("Humanoid")
	humanoid.PlatformStand = false
end)
